
---


## Organizing Code

Keeping your code:

* readable
* correct
* robust
* maintainable

Most of this talk this applies to any language.


---


## Contruct Your Program From Parts

* functions, modules, packages
* dictionaries, lists, sets
* well defined API's between parts

![Tree](graphs/tree.svg)


---

## Contain the Mess

Some parts of your code are always going to be messy.

Quarantine the mess:

* put it in a function or module
* make a well defined API for it

The rest of your code will now be cleaner.


---

## State is Evil

* use pure functions when possible
* a pure function doesn't modify anything outside itself
* keep I/O near ``main()``


---


## Don't Repeat Yourself (DRY)

* don't copy and paste code
* when you see repetition, it might be time for a function

(Todo: Add example.)


---


## But Don't Contort Yourself

To avoid this repetition:

```python
MODE_NUMS = {
    'stopped': 0,
    'playing': 1,
    'recording': 3,
}
MODE_NAMES = {
    0: 'stopped',
    1: 'playing',
    3: 'recording',
}
```

you could add code that adds the flipped values:

```python
MODES = {
    'stopped': 0,
    'playing': 1,
    'recording': 3,
}
# Add reverse lookup.
MODE_NAMES = {value: name for name, value in MODES.items()}
```

but it's not worth it for such a small table and it makes the code harder to understand.


---

## Don't Copy and Paste Code

Instead of:

```python
def make_employee_card(employee):
    card = {
        'first_name': employee['first_name'],
        'last_name': employee['last_name'],
        'type': 'employee',
    }

def make_student_card(student):

```

do:

https://en.wikipedia.org/wiki/Copy_and_paste_programming


---

## Break it Into Functions

* if a functions gets to long
* if a function does more than one thing

When you find yourself commenting blocks of code:

```python
def (name):

```

it's time for a function:




---

## Use Dictionaries Instead of Ifs

Instead of:

```python
def get_mode_name(mode):
    if mode == 0:
        return 'stopped'
    elif mode == 1:
        return 'playing'
    elif mode == 3':
        return 'recording':
    else:
        raise ValueError('Unknown mode {}'.format(mode))

>>> get_mode_name(1)
playing
```

do:

```python
MODES = {
    0: 'mode',
    1: 'playing',
    3: 'recording',
}

>>> MODES[1]
playing
```


---

## Spagetti Code

![Test](images/spaghetti.svg)


---

## Readability

You spend a lot more time reading code than writing it. Spend some time making your code readable and you'll save lots of time and frustration later.

* use good names
* use [PEP-8](https://www.python.org/dev/peps/pep-0008/) as a guideline
* add whitespace to break things up

Readability leads to understanding, understanding leads to reliable programs.


---

## Modules

You've already written a module!

A module is a Python file.
A package is a directory of modules.
A module contains functions.

A module is a namespace.


---

## Functions are Verbs

Use verbs as function names:

```python
person = get_person(db, username)
```

```python
if is_student(person):
    # Do student specific thing.
```



---

## Naming Conventions

``_underscore``.

* internal to module (or object)
* not enforced, but is a clue that it's not a part of the API


---

## Don't Overuse Classes

https://www.youtube.com/watch?v=o9pEzgHorH0

Classes are great when you need them but:

* Python is object oriented, not class oriented
* don't use classes for everything
* if you have a class with only one method it should be a function
* use dictionaries instead of objects
* use modules and packages to group related things together
* use dyck typing
* use embedding instead of subclassing
* don't use a class as a name space. That's what modules are for


---

## ``__init__.py``

* is the top level module
* should only contain imports (no code or data)

Example:

```python
from .messages import Message
from .midifile import MidiFile, MidiTrack
from .parser import Parser, parse, parse_all
```


---

* build large programs as layers on top of layers (libraries on top of libraries)
* a part should only know what it needs to know
* avoid global variables (show in graph)
* no global config or args object
* each module is a library

* no global object that you pass around everywhere

(Example: program where every function uses the config object.)

All imports at the top of the file (so you can see where things come from.) And what the module requires.

Don't use "from mod import *"

Spaghetti / lasagna / macaroni.

A function or module should know as little as possible about the outside world.

avoid magic

you can test each part on its own

and it's easier to move things around

absolute vs. relative import

You can study and test each part on its own. No need to worry about the rest of the code.

I like to make things easier for myself. I can't keep that many things in my head at one time.

I write little functions and test them interactively (or in automated tests).

Naming things well makes the code easier to read
If you find it hard to name a function it's probably doing more than one thing

Build your programs as a bunch of little libraries.

These should be layered so the bottom libraries don't have to know anything about the ones above.

Make every part of the program a building block for building more program.

Keep I/O in one place. (Near main().)

I optimize for user happiness. (End users and programmers.)

Keep your imports at the top of the file.

``import x as y``, `from .mod import func`

``from subprocess import check_call as run``

